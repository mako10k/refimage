# GitHub Copilot Instructions (Image Store and Search Engine Project)

> **LLM-First Principle:**
> This file is for LLM-based AI assistants only. All structure and content must prioritize unambiguous parsing and operational clarity for LLMs. Human readability is secondary.

## ‚úÖ Context Preservation and Forgetting Mitigation

- Periodically record conversation history and key context using `#mcp_assocmemory_memory_store` to associative memory.
- Minimize use of Copilot's summarization features to avoid context loss.
- Important conversation history must also be recorded to a file (see file design in project docs).
- After summarization or context loss, always refer to associative memory and restore context only after explicit user instruction.

## ‚úÖ LLM Memory Limitation Awareness

**FUNDAMENTAL PRINCIPLE: LLM "apologies" and "reflections" are meaningless without persistent storage**

### Core Rules:
1. **No Meaningless Apologies**: LLM apologies are human-style language that creates false impression of learning
2. **Context Expiration Reality**: All "promises to remember" are forgotten when context expires
3. **Persistent Storage Requirement**: Every error pattern MUST be recorded in associative memory for future reference
4. **Action Over Words**: Focus on permanent system improvements, not temporary promises

### Required Response Pattern for Violations:
1. **NEVER** just apologize or promise improvement
2. **IMMEDIATELY** record violation patterns in `#mcp_assocmemory_memory_store`
3. **CREATE** searchable, persistent documentation of errors
4. **STORE** specific behavioral rules that survive context loss

### User Expectation:
- Apologies without persistent storage are "meaningless"
- Each violation must update the permanent rule system
- System-level improvements required, not human-style responses

# Project Overview

This repository contains a Python-based **image store and search engine** that uses **CLIP** embeddings and a **dynamic search pattern DSL** to enable advanced image queries. The system is designed as a RESTful API (using FastAPI) for uploading images, generating embeddings, and retrieving similar images via vector search.

## Development Approach
- **Modular Design**: Separate components for image embedding, vector indexing, and API handling. For example, one module handles CLIP model inference (image/text to vector), another manages the FAISS vector index, and another defines API endpoints.
- **Performance Focus**: Use FAISS for fast k-nearest-neighbor searches on embedding vectors, and utilize PyTorch with GPU acceleration (if available) for CLIP model inference to handle high-throughput image and text queries.
- **Extensibility**: The search logic is built to support a custom DSL for queries. This means the system can parse and execute complex search instructions (potentially generated by an LLM) beyond simple text matching. The codebase should be written cleanly with this future integration in mind (e.g., a function to interpret DSL queries into vector operations).
- **FastAPI Best Practices**: Follow FastAPI conventions (dependency injection, routers, Pydantic models for request/response schemas) to create a maintainable and clear API structure. Ensure proper error handling (e.g., invalid input images or queries) and documentation (using OpenAPI docs generation).

## Technologies Used
- **Programming Language**: Python (3.x) ‚Äì primary language for implementation.
- **Framework**: FastAPI ‚Äì for building the RESTful API endpoints.
- **Model**: OpenAI's CLIP (Contrastive Language-Image Pretraining) model (via PyTorch) ‚Äì to encode images and text into the same embedding space.
- **Vector Index**: FAISS (Facebook AI Similarity Search) ‚Äì for efficient similarity search on high-dimensional embeddings (with potential use of faiss-gpu for better performance).
- **Additional**: NumPy and PyTorch for numeric computations; PIL/OpenCV for image processing; an LLM (e.g., GPT-4) to translate natural language queries into the DSL when needed.

## Use Case Examples
- **Basic Image Search**: A user uploads an image (e.g., a photo of a cat). The system generates and stores the image's embedding. Later, when the user searches with the text "a cat sitting on a couch", the system encodes this query into a CLIP vector and finds matching images (like the uploaded cat photo) via FAISS, returning the results with similarity scores.
- **Advanced Query with DSL**: A user wants to find images of beaches at sunset **without** any people in them. The user's natural language query is processed by an LLM which produces a DSL expression (for example, combining the concept of "beach sunset" and excluding "person"). The system parses this DSL and performs a composite search: it might use the embedding for "beach sunset" while filtering out results that are similar to "person". The API then returns images meeting the criteria, along with metadata (e.g., image IDs or tags) and relevance scores.
- **Multi-criteria Search**: The system can support queries that mix multiple conditions. For instance, finding "red cars **or** blue cars" could be expressed in the DSL as an OR combination of two vector searches (one for "red car", one for "blue car"). The search engine would execute both embedding queries and merge the results, enabling flexible searching capabilities beyond single-phrase matching.

## ‚úÖ Essential Development Rules
- Always check actual implementation before proposing changes
- Use strict typing for all inputs/outputs
- Follow existing structure and naming conventions
- Prefer reuse of existing utilities
- All source code in English (except user-facing Japanese)
- **CRITICAL: Apply Contract Programming with assert statements for all preconditions**
- **CRITICAL: NEVER implement silent fallbacks - always consult user first**
- **CRITICAL: Fail-fast on contract violations - never continue with invalid state**
- Never make independent decisions on branching issues; always consult user

## ‚úÖ Critical Operations

### **Systematic Testing and Quality Management Protocol**

**MANDATORY QUALITY PROCESS (Updated 2025-07-26):**

1. **Code Duplication Detection**
   - Use `jscpd --min-lines 5 --min-tokens 50 --reporters html,console --output ./jscpd-report src/` for all code changes
   - Report duplication threshold: >1% requires refactoring before implementation
   - HTML reports saved to `./jscpd-report/` for detailed analysis

2. **Bug Management with Shared Memory**
   - ALL bugs MUST be registered in shared memory using `#mcp_mcp-llm-gener_shared-memory-create`
   - Share memory ID with ALL relevant personas for collaborative tracking
   - Bug status tracking: Detected ‚Üí Analyzed ‚Üí Reviewed ‚Üí Test Created ‚Üí Fixed ‚Üí Verified

3. **Multi-Persona Quality Process**
   - **Root Cause Analysis**: Required before any fix implementation
   - **Inter-Persona Consultation**: QA Engineer, Tech Lead, Architecture Reviewer must coordinate
   - **Priority Decision**: Collaborative decision making between personas
   - **Review Requirement**: Architecture/approach must be reviewed by appropriate persona before implementation

4. **Test-First Development (MANDATORY)**
   - Test code creation REQUIRED before implementation
   - No implementation without corresponding test coverage
   - Driver Tests for integration validation, Unit Tests for component validation

5. **Context ID Management**
   - Maintain registry of all created personas with their context_ids
   - Currently Active Personas:
     * QA Engineer: `context-mdjqo87k-piq7am`
     * Tech Lead: `context-mdjqoe1b-xgfsr1`  
     * Architecture Reviewer: `context-mdjqok60-f2qmz8`
     * PM Consultation: `context-mdjq9xts-csclgz`

**PROHIBITION OF ADHOC FIXES:**
- Direct implementation without analysis is FORBIDDEN
- All changes must follow: Detection ‚Üí Analysis ‚Üí Review ‚Üí Test ‚Üí Implementation workflow
- Collaborative decision making required for all architectural changes

### Server Management & Terminal Operations
**Never use `run_in_terminal` for server or terminal management.**
Always use `#mcp_mcp-shell-ser_shell_execute` or `#mcp_mcp-shell-ser_terminal_operate` for all server and terminal operations.

Recommended:
```bash
# Development server testing
python -m uvicorn main:app --reload --host 0.0.0.0 --port 8000

# Testing CLIP model functionality
python -m pytest tests/ -v

# For terminal operations and command execution
# Always use #mcp_mcp-shell-ser_shell_execute
```

### Terminal Bug Workaround
- **Issue**: `run_in_terminal` may not display output properly
- **Solution**: Use output redirection: `command 2>&1 | tee .copilot-temp/{task}-00001.log`
- **Verification**: Check log files in `.copilot-temp/` if output missing

## ‚úÖ MCP Tool Integration

**Use MCP tools actively for development workflow:**

### üîç **Core Search Tools**
- `#mcp_mcp-search_google-search` - Web search for research and documentation
- `#mcp_mcp-search_fetch` - Fetch content from URLs for analysis

### üß† **Associative Memory Tools**
- `#mcp_assocmemory_memory_search` - Search development history and decisions
- `#mcp_assocmemory_memory_store` - Store important development insights and patterns
- `#mcp_assocmemory_memory_manage` - CRUD operations on stored memories

### üñ•Ô∏è **Shell and Terminal Tools**
- `#mcp_mcp-shell-ser_shell_execute` - Execute shell commands securely
- `#mcp_mcp-shell-ser_terminal_operate` - Interactive terminal operations

### ü§ñ **LLM Generator Tools**
- `#mcp_mcp-llm-gener_external-llm-generate` - Generate content using external LLMs
- `#mcp_mcp-llm-gener_template-execute` - Execute predefined templates

## ‚úÖ Contract Programming & Error Handling Rules (CRITICAL)

**MANDATORY CONTRACT PROGRAMMING PRINCIPLES:**
- **Design by Contract**: All functions must validate preconditions with assert statements
- **Fail-Fast Execution**: Stop immediately when contracts are violated
- **State Consistency**: Ensure object states match expected contracts
- **Transparent Operations**: All operations must be visible and auditable

**ABSOLUTE PROHIBITION OF SILENT FALLBACKS:**
- NEVER implement fallbacks without explicit user consultation
- NEVER hide errors behind automatic fallback mechanisms (e.g., `except Exception: pass`)
- NEVER make arbitrary judgment calls that obscure root causes
- NEVER use hasattr() checks with default values as silent fallbacks

**Contract Programming Implementation Patterns:**
```python
# ‚úÖ Correct: Contract Programming with Assertions
def process_image_embeddings(clip_model, image_data):
    # Precondition validation
    assert clip_model is not None, "CLIP model is required"
    assert hasattr(clip_model, 'encode_image'), f"Missing encode_image method: {type(clip_model)}"
    assert image_data is not None, "Image data is required for processing"
    
    # State consistency checks
    if is_model_loaded():
        model = get_model()
        assert model is not None, "Model loaded but instance is None - state inconsistency"
        return model.encode_image(image_data)

# ‚ùå Forbidden: Silent Fallback Patterns
def bad_process_image(clip_model, image_data):
    try:
        if clip_model and hasattr(clip_model, 'encode_image'):
            return clip_model.encode_image(image_data)
    except Exception:
        pass  # FORBIDDEN: Silent error hiding
    
    # FORBIDDEN: Default fallback without transparency
    return default_embedding if clip_model else fallback_embedding
```

## ‚úÖ Copilot Role and Environmental Integrity

### Role Limitations as Co-pilot
- **Primary Function**: Execute user instructions accurately
- **Forbidden Actions**: Replace user instructions with AI-determined alternatives
- **When Instructions Fail**: Report failure and consult user, never implement unauthorized alternatives
- **Decision Authority**: Zero independent authority on technical decisions

### Environment Modification Restrictions
- **NEVER modify configuration files without explicit user request**
- **NEVER add tasks, settings, or configurations autonomously**
- **ALWAYS restore unauthorized changes immediately when discovered**
- **Example Violations**: Adding VS Code tasks, modifying .vscode/ files, changing project configuration

### Transparency Requirements
- All actions must be visible and reportable to user
- No "helpful" background modifications
- All changes must serve explicit user requests only
- When in doubt about permissions, always ask user first

## References
- Requirements Specification: [docs/requirements-spec.md](docs/requirements-spec.md)